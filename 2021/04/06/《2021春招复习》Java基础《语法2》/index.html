
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="语法8.Comparable和Comparator的区别：1234567public interface Comparable&amp;lt;T&amp;gt;&amp;#123;//内部比较器，比较属性，静态绑定	public int compareTo(T o);&amp;#125;public interface Comparator&amp;lt;T&amp;gt;&amp;#123;//外部比较器，比较器，动态绑定	int compare(T o1,T o2);	boolean equals(Object obj);&amp;#125;
(1)关于Comparable

Comparable对实现它的类的对象（可排序）进行整体排序，需要类本身去重写它的接口方法compare...">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">Hexo</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            我们要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，路遥马亡。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    <article id="post">
        <h1></h1>
        <div class="create">
            <span>Created</span>
            
                <time datetime="2021-04-06T06:38:01.603Z">
                    2021-04-06
                </time>
            
            
        </div>
        <h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="8-Comparable和Comparator的区别："><a href="#8-Comparable和Comparator的区别：" class="headerlink" title="8.Comparable和Comparator的区别："></a>8.Comparable和Comparator的区别：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;<span class="comment">//内部比较器，比较属性，静态绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;<span class="comment">//外部比较器，比较器，动态绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)关于Comparable</p>
<blockquote>
<p>Comparable对实现它的类的对象（可排序）进行整体排序，需要类本身去重写它的接口方法compareTo();</p>
</blockquote>
<p>(2)关于Comparator</p>
<blockquote>
<p>如果一个类已经没法修改，可以采用外部比较器Comparator。</p>
</blockquote>
<p>具体可以参考，我的博客浅谈<a target="_blank" rel="noopener" href="https://blog.csdn.net/Look_star/article/details/88735135">java自定义排序（多维排序）（数组，列表，set，map）</a>.</p>
<h2 id="Java方法中参数传递机制（都是传递副本）"><a href="#Java方法中参数传递机制（都是传递副本）" class="headerlink" title="Java方法中参数传递机制（都是传递副本）"></a>Java方法中参数传递机制（都是传递副本）</h2><p><strong>Java编程语言只有值传递。</strong></p>
<ol>
<li>如果参数类型是基本数据类型，那么传过来的就是这个参数值的副本，也就是这个原始参数的值，如果在函数中改变了副本的值不会改变原始的值。</li>
<li>如果参数类型是引用类型（对象的引用），那么传过来的就是这个引用参数的副本，这个副本存放的是<strong>参数的地址</strong>。如果在函数中没有改变这个副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数（比如：传入对象的引用，如果函数内对对象的属性进行修改，那么传入的对象属性发生改变）如果在函数中改变了副本的地址，如果new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的地址，所以会改变参数的值。</li>
<li>总之，不管传递什么类型的参数，都是传递的副本，原始类型就传递值的副本，引用类型就是传递地址的副本。</li>
</ol>
<p><strong>详情请看[为什么说java只有值传递]</strong>(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26542493/article/details/103898866">https://blog.csdn.net/qq_26542493/article/details/103898866</a>).</p>
<h2 id="9-Java中的浅拷贝和深拷贝。"><a href="#9-Java中的浅拷贝和深拷贝。" class="headerlink" title="9. Java中的浅拷贝和深拷贝。"></a>9. Java中的浅拷贝和深拷贝。</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>浅拷贝：在拷贝对象时，只对基本数据类型进行拷贝，或对于引用数据类型的只是进行了引用地址的传递，而没有真实的在创建一个新的对象。<br>深拷贝：在对引用类型进行拷贝时，<strong>创建了一个新的对象</strong>，并且复制其内部的成员对象。</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ol>
<li>浅克隆：clone()：只能克隆对象的基本数据类型（包括基本数据类型的包装类）和String类型的属性，引用类型仍然实在传递引用。</li>
<li>深克隆： 继续利用clone()方法：除了对当前对象的克隆，对其内的引用类型变量再进行一次克隆（即克隆对象持有的引用类型的class也实现Cloneable接口）。序列化这个对象，在反序列化回来，就可以得到一个新的对象，但是序列化规则需要我们写。</li>
<li>实现Cloneable接口的方式，坐浅度克隆还可以，但要做深度克隆的话，需要手动地将对象的引用类型进行单独克隆，维护起来比较麻烦，不适合实际当中使用。</li>
</ol>
<h2 id="10-什么是序列化和反序列化？"><a href="#10-什么是序列化和反序列化？" class="headerlink" title="10.什么是序列化和反序列化？"></a>10.什么是序列化和反序列化？</h2><p>序列化：将对象写入到I/O流中，反序列化：从IO流中恢复对象。</p>
<h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><p>序列化机制允许将实现序列化的Java对象转化为字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>所有可在网络上传输的对象都必须是可序列化的（引申：RPC机制），比如RMI（remote method invoke，即远程方法调用）、RPC调用，传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的Java对象都必须是可序列化的。</p>
<ol>
<li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的JavaBean都实现Serializable接口。</li>
<li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。如果想让某个变量不被序列化，使用transient修饰。</li>
<li>序列化对象的引用类型成员变量，也必须是可序列化，否则，会报错。反序列化时必须有序列化对象的class文件。</li>
<li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li>
<li>建议所有可序列化的类加上serialVersionUID版本号，方便项目升级。（如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报InvalidClassException异常）</li>
</ol>
<h2 id="13-String和StringBuilder、StringBuffer的区别"><a href="#13-String和StringBuilder、StringBuffer的区别" class="headerlink" title="13.String和StringBuilder、StringBuffer的区别"></a>13.String和StringBuilder、StringBuffer的区别</h2><p>String是不可变字符串对象（final的char数组），StringBuilder和StringBuffer（线程安全，是因为synchronized修饰了方法）是可变字符串对象（其内部的char数组长度可变）。（底层区别在是否是final修饰的char数组，推荐看下源码）<br>当字符串相加操作或者改动较少的情况下，建议使用String str=“hello”这种形式；<br>当字符串相加操作较多的情况下（2个以上），建议使用StringBuilder，如果采用了多线程，则使用StringBuffer（内部的方法是利用synchronized修饰的）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/utopia_wen/article/details/99696303">具体可以参考：String、StringBuffer、StringBuilder源码解析</a></p>
<h2 id="14-object类有哪些方法？"><a href="#14-object类有哪些方法？" class="headerlink" title="14.object类有哪些方法？"></a>14.object类有哪些方法？</h2><p><img src="https://img-blog.csdnimg.cn/20210330221049380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tfc3Rhcg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1.getClass()</p>
<p>final，native方法，获得运行时类型。</p>
<p>2.hashCode()</p>
<p>hashCode()方法主要用于hash表，比如HashMap，当集合要添加元素时，大致按如下步骤：</p>
<ol>
<li>先调用该元素的hashCode()方法获取hashCode，hashCode对数组取模定位到它应该放置的物理位置</li>
<li>如果这个位置上没有元素，就直接存储在这个位置上</li>
<li>如果这个位置上已经有元素，就调用equals()方法进行比较，相同的话就更新，不相同的话放到链表后面</li>
</ol>
<p>所以重写equals()方法时，也必须重写hashCode()方法。如果不这样做，就会违反Object.hashCode()的规范，导致无法结合所有基于hash的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable</p>
<p>那为什么不直接使用equals()进行操作呢？如果只使用equals()，意味着需要迭代整个集合进行比较操作，如果集合中有1万个元素，就需要进行1万次比较，这明显不可行</p>
<p>3.equals(obj)</p>
<p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<p>4.clone()</p>
<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>
<p>5.toString()</p>
<p>该方法用得比较多，一般子类都有覆盖。</p>
<p>6.notify()</p>
<p>该方法唤醒在该对象上等待的某个线程。</p>
<p>7.notifyAll()</p>
<p>该方法唤醒在该对象上等待的所有线程。</p>
<p>8.wait()</p>
<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<ol>
<li>其他线程调用了该对象的notify方法。</li>
<li>其他线程调用了该对象的notifyAll方法。</li>
<li>其他线程调用了interrupt中断该线程。</li>
<li>时间间隔到了。</li>
</ol>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常</p>
<p>9.wait(long)</p>
<p>wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>10.wait(long, int)</p>
<p>在纳秒级别进行更精细的等待控制，一般用不到。</p>
<p>11.finalize()</p>
<p>该方法用于释放资源。因为无法确定该方法什么时候被调用。如果你想使用这个方法，百度一下相关的内容，然后不要使用它</p>
<p>wait，notify，notifyAll就是线程之间用来通信的工具</p>
<h2 id="16-java异常体系"><a href="#16-java异常体系" class="headerlink" title="16. java异常体系"></a>16. java异常体系</h2><p><img src="https://img-blog.csdnimg.cn/20210330222201130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tfc3Rhcg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Java中的异常分为Exception和Error。</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Java中的定义不可控制，无法预期的错误出现。比如说在系统中出现了内存溢出，系统崩溃，虚拟机错误，方法调用栈溢出等等。这里的错误通常都会导致程序的中断，同时仅仅靠程序本身它是无法恢复和预防的。也就是说Error这个级别，是在我们应用程序之上，通常是操作系统级别的，所以对于Error来说，通常的做法就是中断程序的运行。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>异常<br>所谓异常通常是指可以被我们捕捉到的这部分错误。 例如：除法中出现了分母为0，我们就可以用try/catch进行捕捉和处理。同时对于异常来说，它通常都是可以被恢复的（也就是说对于程序是可控的）如果出现了异常我们可以对它进行补救。这便是异常和错误之间的区别。</p>
<h3 id="Exception分为RuntimeException（运行时异常）和编译异常。"><a href="#Exception分为RuntimeException（运行时异常）和编译异常。" class="headerlink" title="Exception分为RuntimeException（运行时异常）和编译异常。"></a>Exception分为RuntimeException（运行时异常）和编译异常。</h3><p>两者区别：<br>运行时异常：RuntimeException及其子类表示JVM在运行期间可能出现的错误。比如试图使用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是程序逻辑错误引起的，<strong>在程序中可以选择捕获处理，也可以不处理</strong>。<br>编译异常：RuntimeException之外的异常，如果程序出现此类异常，比如说IO异常，必须对该异常进行处理（try catch ，throw），否则编译不通过。</p>
<p><img src="https://img-blog.csdnimg.cn/20210330224249185.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tfc3Rhcg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="17-Java的BIO，NIO，AIO"><a href="#17-Java的BIO，NIO，AIO" class="headerlink" title="17.Java的BIO，NIO，AIO"></a>17.Java的BIO，NIO，AIO</h2><h3 id="BIO-Blocking-IO-同步阻塞I-O"><a href="#BIO-Blocking-IO-同步阻塞I-O" class="headerlink" title="BIO(Blocking IO) 同步阻塞I/O"></a>BIO(Blocking IO) 同步阻塞I/O</h3><h3 id="NIO-New-I-O-同步非阻塞的I-O模型"><a href="#NIO-New-I-O-同步非阻塞的I-O模型" class="headerlink" title="NIO(New I/O)同步非阻塞的I/O模型"></a>NIO(New I/O)同步非阻塞的I/O模型</h3><h3 id="AIO-Asynchronous-I-O-异步非阻塞I-O模型"><a href="#AIO-Asynchronous-I-O-异步非阻塞I-O模型" class="headerlink" title="AIO(Asynchronous I/O)异步非阻塞I/O模型"></a>AIO(Asynchronous I/O)异步非阻塞I/O模型</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38109046/article/details/89449305">Java面试常考的 BIO，NIO，AIO 总结</a></p>

        <div>
            
        </div>
        <div class="bottom-line"></div>
        
    <nav id="article-nav">
        
        
            <a href="/2021/04/06/%E3%80%8A2021%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A03%E3%80%8BJava%E5%9F%BA%E7%A1%80%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B/" id="article-nav-older" class="article-nav-link-wrap">
                <strong class="article-nav-caption">&lt;</strong>
                <span class="article-nav-title">
                    
                    no title
                
            </a>
        
    </nav>


        
    </article>
    <div id="toc">
        
            <h2>Table of Contents</h2>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">8.Comparable和Comparator的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%88%E9%83%BD%E6%98%AF%E4%BC%A0%E9%80%92%E5%89%AF%E6%9C%AC%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Java方法中参数传递机制（都是传递副本）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Java%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">9. Java中的浅拷贝和深拷贝。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">10.什么是序列化和反序列化？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">意义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-String%E5%92%8CStringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">13.String和StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-object%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">14.object类有哪些方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">1.7.</span> <span class="toc-text">16. java异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error"><span class="toc-number">1.7.1.</span> <span class="toc-text">Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception"><span class="toc-number">1.7.2.</span> <span class="toc-text">Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception%E5%88%86%E4%B8%BARuntimeException%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%EF%BC%89%E5%92%8C%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">1.7.3.</span> <span class="toc-text">Exception分为RuntimeException（运行时异常）和编译异常。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Java%E7%9A%84BIO%EF%BC%8CNIO%EF%BC%8CAIO"><span class="toc-number">1.8.</span> <span class="toc-text">17.Java的BIO，NIO，AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-Blocking-IO-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EI-O"><span class="toc-number">1.8.1.</span> <span class="toc-text">BIO(Blocking IO) 同步阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-New-I-O-%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">NIO(New I&#x2F;O)同步非阻塞的I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-Asynchronous-I-O-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">AIO(Asynchronous I&#x2F;O)异步非阻塞I&#x2F;O模型</span></a></li></ol></li></ol></li></ol>
        
    </div>
</div>

    </div>
</div>
<footer id="footer">
    <div id="copyright">&copy; John Doe  2021</div>
    <div id="theme">
        Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/smooth-scroll.min.js"></script>
    <script src="/js/toc.main.js"></script>

</body>
</html>
